# This file was generated. See https://daggerverse.dev/mod/github.com/shykes/gha
name: git --url=https://github.com/$GITHUB_REPOSITORY branch --name=$GITHUB_REF tree glob --pattern=*
"on":
    push: {}
jobs:
    dagger:
        runs-on: ubuntu-latest
        steps:
            - name: Checkout
              uses: actions/checkout@v4
            - name: scripts/install-dagger.sh
              id: install-dagger
              run: |
                #!/bin/bash

                set -o pipefail
                # Fallback to /usr/local for backwards compatability
                prefix_dir="${RUNNER_TEMP:-/usr/local}"

                # Ensure the dir is writable otherwise fallback to tmpdir
                if [[ ! -d "$prefix_dir" ]] || [[ ! -w "$prefix_dir" ]]; then
                    prefix_dir="$(mktemp -d)"
                fi
                printf '%s/bin' "$prefix_dir" >> $GITHUB_PATH

                # If the dagger version is 'latest', set the version back to an empty
                # string. This allows the install script to detect and install the latest
                # version itself
                if [[ "$DAGGER_VERSION" == "latest" ]]; then
                  DAGGER_VERSION=
                fi

                # The install.sh script creates path ${prefix_dir}/bin
                curl -fsS https://dl.dagger.io/dagger/install.sh | BIN_DIR=${prefix_dir}/bin sh
              env:
                DAGGER_VERSION: latest
              shell: bash
            - name: scripts/exec.sh
              id: exec
              run: |
                #!/bin/bash

                # Ensure the command is provided as an environment variable
                if [ -z "$COMMAND" ]; then
                  echo "Error: Please set the COMMAND environment variable."
                  exit 1
                fi

                tmp=$(mktemp -d)
                (
                    cd $tmp

                    # Create named pipes (FIFOs) for stdout and stderr
                    mkfifo stdout.fifo stderr.fifo

                    # Set up tee to capture and display stdout and stderr
                    tee stdout.txt < stdout.fifo &
                    tee stderr.txt < stderr.fifo >&2 &

                    # Run the command, capturing stdout and stderr in the FIFOs
                    ( eval "$COMMAND" ) > stdout.fifo 2> stderr.fifo

                    # Wait for all background jobs to finish
                    wait
                )

                # Expose the outputs as GitHub Actions step outputs directly from the files
                # Multi-line outputs are handled with the '<<EOF' syntax
                {
                    echo 'stdout<<EOF'
                    cat "$tmp/stdout.txt"
                    echo 'EOF'
                    echo 'stderr<<EOF'
                    cat "$tmp/stderr.txt"
                    echo 'EOF'
                } > "${GITHUB_OUTPUT:=github-output.txt}"
              env:
                _EXPERIMENTAL_DAGGER_CLOUD_TOKEN: ${{ secrets.DAGGER_CLOUD_TOKEN }}
                COMMAND: dagger call -q git --url=https://github.com/$GITHUB_REPOSITORY branch --name=$GITHUB_REF tree glob --pattern=*
                DAGGER_CLOUD_TOKEN: ${{ secrets.DAGGER_CLOUD_TOKEN }}
                DAGGER_MODULE: github.com/shykes/core
                GITHUB_ACTION: ${{ github.action }}
                GITHUB_ACTION_PATH: ${{ github.action_path }}
                GITHUB_ACTION_REF: ${{ github.action_ref }}
                GITHUB_ACTION_REPOSITORY: ${{ github.action_repository }}
                GITHUB_ACTION_STATUS: ${{ github.action_status }}
                GITHUB_ACTOR: ${{ github.actor }}
                GITHUB_ACTOR_ID: ${{ github.actor_id }}
                GITHUB_API_URL: ${{ github.api_url }}
                GITHUB_BASE_REF: ${{ github.base_ref }}
                GITHUB_ENV: ${{ github.env }}
                GITHUB_EVENT_NAME: ${{ github.event_name }}
                GITHUB_EVENT_PATH: ${{ github.event_path }}
                GITHUB_GRAPHQL_URL: ${{ github.graphql_url }}
                GITHUB_HEAD_REF: ${{ github.head_ref }}
                GITHUB_JOB: ${{ github.job }}
                GITHUB_PATH: ${{ github.path }}
                GITHUB_REF: ${{ github.ref }}
                GITHUB_REF_NAME: ${{ github.ref_name }}
                GITHUB_REF_PROTECTED: ${{ github.ref_protected }}
                GITHUB_REF_TYPE: ${{ github.ref_type }}
                GITHUB_REPOSITORY: ${{ github.repository }}
                GITHUB_REPOSITORY_ID: ${{ github.repository_id }}
                GITHUB_REPOSITORY_OWNER: ${{ github.repository_owner }}
                GITHUB_REPOSITORY_OWNER_ID: ${{ github.repository_owner_id }}
                GITHUB_REPOSITORYURL: ${{ github.repositoryUrl }}
                GITHUB_RETENTION_DAYS: ${{ github.retention_days }}
                GITHUB_RUN_ATTEMPT: ${{ github.run_attempt }}
                GITHUB_RUN_ID: ${{ github.run_id }}
                GITHUB_RUN_NUMBER: ${{ github.run_number }}
                GITHUB_SECRET_SOURCE: ${{ github.secret_source }}
                GITHUB_SERVER_URL: ${{ github.server_url }}
                GITHUB_SHA: ${{ github.sha }}
                GITHUB_TOKEN: ${{ github.token }}
                GITHUB_TRIGGERING_ACTOR: ${{ github.triggering_actor }}
                GITHUB_WORKFLOW: ${{ github.workflow }}
                GITHUB_WORKFLOW_REF: ${{ github.workflow_ref }}
                GITHUB_WORKFLOW_SHA: ${{ github.workflow_sha }}
                GITHUB_WORKSPACE: ${{ github.workspace }}
              shell: bash
        outputs:
            stderr: ${{ steps.exec.outputs.stderr }}
            stdout: ${{ steps.exec.outputs.stdout }}
